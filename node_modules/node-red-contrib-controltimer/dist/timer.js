"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Timer = exports.DurationUnit = exports.TIMER_TYPE = exports.STATE = void 0;
const events_1 = require("events");
const timers_1 = require("timers");
var ACTION;
(function (ACTION) {
    ACTION["START"] = "START";
    ACTION["STOP"] = "STOP";
    ACTION["RESET"] = "RESET";
    ACTION["PAUSE"] = "PAUSE";
    ACTION["CONTINUE"] = "CONTINUE";
})(ACTION || (ACTION = {}));
var STATE;
(function (STATE) {
    STATE["IDLE"] = "IDLE";
    STATE["RUNNING"] = "RUNNING";
    STATE["STOPPED"] = "STOPPED";
    STATE["PAUSED"] = "PAUSED";
})(STATE = exports.STATE || (exports.STATE = {}));
var TIMER_TYPE;
(function (TIMER_TYPE) {
    TIMER_TYPE["LOOP"] = "loop";
    TIMER_TYPE["DELAY"] = "delay";
})(TIMER_TYPE = exports.TIMER_TYPE || (exports.TIMER_TYPE = {}));
var DurationUnit;
(function (DurationUnit) {
    DurationUnit["MILLISECOND"] = "millisecond";
    DurationUnit["SECOND"] = "second";
    DurationUnit["MINUTE"] = "minute";
    DurationUnit["HOUR"] = "hour";
})(DurationUnit = exports.DurationUnit || (exports.DurationUnit = {}));
class Timer extends events_1.EventEmitter {
    static defaultConfig = {
        timerType: TIMER_TYPE.DELAY,
        duration: 5,
        durationUnit: DurationUnit.SECOND,
        isTimerProgressUpdateEnabled: true,
        timerMaxLoopIterations: 0,
        timerLoopTimeout: 0,
        timerLoopTimeoutUnit: DurationUnit.MILLISECOND,
    };
    static getInstance(config) {
        return new Timer(config);
    }
    config = Timer.defaultConfig;
    configOverride;
    currentState = STATE.IDLE;
    timerId;
    progressUpdateIntervalTimerId;
    stoppedTransitionToIdleTimeoutTimerId;
    loopTimeoutTimeoutTimerId;
    currentLoopIteration = 0;
    pausedTimerRunningMilliseconds;
    timerStartedAtUnixTimestamp;
    constructor(config) {
        super();
        this.config = config; // TODO: Validate config
        this.setCurrentState(STATE.IDLE);
    }
    // ####################
    // ## Public methods ##
    // ####################
    start() {
        this.handleAction(ACTION.START);
    }
    stop() {
        this.handleAction(ACTION.STOP);
    }
    reset() {
        this.handleAction(ACTION.RESET);
    }
    pause() {
        this.handleAction(ACTION.PAUSE);
    }
    continue() {
        this.handleAction(ACTION.CONTINUE);
    }
    hardReset() {
        this.configOverride = undefined;
        this.softReset();
    }
    softReset() {
        this.currentState = STATE.IDLE;
        this.destroyTimers();
        this.currentLoopIteration = 0;
        this.pausedTimerRunningMilliseconds = undefined;
        this.timerStartedAtUnixTimestamp = undefined;
    }
    setConfigOverride(configOverride) {
        this.configOverride = configOverride; // TODO: Validate configOverride
        this.emit('state', {
            state: this.currentState,
            progress: this.currentState === STATE.PAUSED ? this.getPausedTimerProgress() : this.getRunningTimerProgress(),
        });
    }
    getState() {
        return this.currentState;
    }
    // ###########################
    // ## Timer action handling ##
    // ###########################
    handleAction(action) {
        if (this.currentState === STATE.IDLE) {
            if (action === ACTION.START) {
                this.startTimer();
            }
        }
        if (this.currentState === STATE.RUNNING) {
            if (action === ACTION.STOP) {
                this.stopTimer();
            }
            if (action === ACTION.RESET) {
                this.resetTimer();
            }
            if (action === ACTION.PAUSE) {
                this.pauseTimer();
            }
        }
        if (this.currentState === STATE.STOPPED) {
            if (action === ACTION.START) {
                this.startTimer();
            }
        }
        if (this.currentState === STATE.PAUSED) {
            if (action === ACTION.STOP) {
                this.stopTimer();
            }
            if (action === ACTION.RESET) {
                this.resetTimer();
            }
            if (action === ACTION.CONTINUE) {
                this.continueTimer();
            }
        }
    }
    // ##########################
    // ## Timer action methods ##
    // ##########################
    startTimer() {
        this.softReset();
        this.timerId = this.createAndGetTimer();
        this.setCurrentState(STATE.RUNNING, this.getRunningTimerProgress());
        this.startProgressUpdateTimer();
    }
    stopTimer() {
        this.hardReset();
        this.setCurrentState(STATE.STOPPED);
        this.startStoppedTransitionToIdleTimer();
    }
    resetTimer() {
        this.softReset();
        this.timerId = this.createAndGetTimer();
        this.setCurrentState(STATE.RUNNING, this.getRunningTimerProgress());
        this.startProgressUpdateTimer();
    }
    pauseTimer() {
        this.destroyTimers();
        const previousRunningDurationInMilliseconds = this.pausedTimerRunningMilliseconds ?? 0;
        this.pausedTimerRunningMilliseconds = Date.now() - this.timerStartedAtUnixTimestamp + previousRunningDurationInMilliseconds;
        this.timerStartedAtUnixTimestamp = undefined;
        this.setCurrentState(STATE.PAUSED, this.getPausedTimerProgress());
    }
    continueTimer() {
        this.timerId = this.createAndGetTimer(this.timerDurationInMilliseconds - this.pausedTimerRunningMilliseconds);
        this.setCurrentState(STATE.RUNNING, this.getRunningTimerProgress());
        this.startProgressUpdateTimer();
    }
    finishTimer() {
        this.hardReset();
        this.setCurrentState(STATE.IDLE);
    }
    // ###########################
    // ## Timer helpers methods ##
    // ###########################
    createAndGetTimer(durationInMillisecondsOverride) {
        const durationInMilliseconds = durationInMillisecondsOverride ?? this.timerDurationInMilliseconds;
        if ((this.config.timerType === TIMER_TYPE.LOOP && !this.configOverride) || this.configOverride?.timerType === TIMER_TYPE.LOOP) {
            this.pausedTimerRunningMilliseconds = durationInMillisecondsOverride ? this.pausedTimerRunningMilliseconds : undefined;
            this.timerStartedAtUnixTimestamp = Date.now();
            this.startLoopTimeoutTimer();
            return setInterval(() => {
                this.emit('timer');
                if (durationInMillisecondsOverride && durationInMillisecondsOverride !== this.timerDurationInMilliseconds) {
                    this.resetTimer();
                }
                this.pausedTimerRunningMilliseconds = undefined;
                this.timerStartedAtUnixTimestamp = Date.now();
                this.currentLoopIteration = this.currentLoopIteration + 1;
                if (this.currentLoopIteration === this.config.timerMaxLoopIterations) {
                    this.stopTimer();
                    this.emit('loop-max-iterations');
                }
            }, durationInMilliseconds);
        }
        if ((this.config.timerType === TIMER_TYPE.DELAY && !this.configOverride) || this.configOverride?.timerType === TIMER_TYPE.DELAY) {
            this.pausedTimerRunningMilliseconds = durationInMillisecondsOverride ? this.pausedTimerRunningMilliseconds : undefined;
            this.timerStartedAtUnixTimestamp = Date.now();
            return setTimeout(() => {
                this.emit('timer');
                this.finishTimer();
            }, durationInMilliseconds);
        }
        throw new Error(`Unexpected timer type "${this.configOverride ? this.configOverride.timerType : this.config.timerType}"`);
    }
    destroyTimers() {
        (0, timers_1.clearInterval)(this.timerId);
        (0, timers_1.clearTimeout)(this.timerId);
        (0, timers_1.clearInterval)(this.progressUpdateIntervalTimerId);
        (0, timers_1.clearTimeout)(this.stoppedTransitionToIdleTimeoutTimerId);
        (0, timers_1.clearTimeout)(this.loopTimeoutTimeoutTimerId);
        this.timerId = undefined;
        this.progressUpdateIntervalTimerId = undefined;
        this.stoppedTransitionToIdleTimeoutTimerId = undefined;
        this.loopTimeoutTimeoutTimerId = undefined;
    }
    // ####################################
    // ## Timer setup & teardown methods ##
    // ####################################
    startLoopTimeoutTimer() {
        (0, timers_1.clearTimeout)(this.loopTimeoutTimeoutTimerId);
        this.loopTimeoutTimeoutTimerId = undefined;
        if (this.config.timerLoopTimeout === 0) {
            return;
        }
        this.loopTimeoutTimeoutTimerId = setTimeout(() => {
            this.stopTimer();
            this.emit('loop-timeout');
        }, this.getTimerLoopTimeoutInMilliseconds());
    }
    startProgressUpdateTimer() {
        (0, timers_1.clearInterval)(this.progressUpdateIntervalTimerId);
        this.progressUpdateIntervalTimerId = undefined;
        if (!this.config.isTimerProgressUpdateEnabled) {
            return;
        }
        this.progressUpdateIntervalTimerId = setInterval(() => {
            this.setCurrentState(STATE.RUNNING, this.getRunningTimerProgress());
        }, 50);
    }
    startStoppedTransitionToIdleTimer() {
        (0, timers_1.clearTimeout)(this.stoppedTransitionToIdleTimeoutTimerId);
        this.stoppedTransitionToIdleTimeoutTimerId = undefined;
        if (this.currentState !== STATE.STOPPED) {
            return;
        }
        this.stoppedTransitionToIdleTimeoutTimerId = setTimeout(() => {
            this.finishTimer();
        }, 1000 * 10);
    }
    // #############################
    // ## Other utility functions ##
    // #############################
    setCurrentState(state, progress = '') {
        this.currentState = state;
        this.emit('state', { state, progress });
        this.emit(state);
    }
    getRunningTimerProgress() {
        if (!this.config.isTimerProgressUpdateEnabled) {
            return '';
        }
        const previousRunningDurationInMilliseconds = this.pausedTimerRunningMilliseconds ?? 0;
        const timerPercentageCompletion = (100 * (Date.now() - this.timerStartedAtUnixTimestamp + previousRunningDurationInMilliseconds)) / this.timerDurationInMilliseconds;
        return this.getTimerProgressString(timerPercentageCompletion);
    }
    getPausedTimerProgress() {
        if (!this.config.isTimerProgressUpdateEnabled) {
            return '';
        }
        const timerPercentageCompletion = (100 * this.pausedTimerRunningMilliseconds) / this.timerDurationInMilliseconds;
        return this.getTimerProgressString(timerPercentageCompletion);
    }
    getTimerProgressString(timerPercentageCompletion) {
        return ` ${Number(timerPercentageCompletion).toFixed(1)}% of ${this.timerDuration} ${this.timerDurationUnit}(s)`;
    }
    get timerDuration() {
        return this.configOverride?.duration ?? this.config.duration;
    }
    get timerDurationUnit() {
        return this.configOverride?.durationUnit ?? this.config.durationUnit;
    }
    get timerDurationInMilliseconds() {
        return Timer.getDurationInMilliseconds(this.timerDuration, this.timerDurationUnit);
    }
    getTimerLoopTimeoutInMilliseconds() {
        return Timer.getDurationInMilliseconds(this.config.timerLoopTimeout, this.config.timerLoopTimeoutUnit);
    }
    static getDurationInMilliseconds(duration, durationUnit) {
        if (durationUnit === DurationUnit.MILLISECOND) {
            return duration;
        }
        if (durationUnit === DurationUnit.SECOND) {
            return duration * 1000;
        }
        if (durationUnit === DurationUnit.MINUTE) {
            return duration * 60 * 1000;
        }
        if (durationUnit === DurationUnit.HOUR) {
            return duration * 60 * 60 * 1000;
        }
        throw new Error(`Unexpected durationUnit "${durationUnit}"`);
    }
}
exports.Timer = Timer;
