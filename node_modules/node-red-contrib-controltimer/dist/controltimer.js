"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_config_1 = require("./node-config");
const timer_1 = require("./timer");
module.exports = function (RED) {
    RED.nodes.registerType(node_config_1.nodeName, function (config) {
        RED.nodes.createNode(this, config);
        const node = this;
        let lastMessage;
        const getMessage = (message) => ({ [config.actionPropertyName]: message });
        const getTriggerMessage = () => config.outputReceivedMessageOnTimerTrigger ? RED.util.cloneMessage(lastMessage) : getMessage(config.timerTriggeredMessage);
        const getHaltedMessage = () => (config.outputReceivedMessageOnTimerHalt ? RED.util.cloneMessage(lastMessage) : getMessage(config.timerHaltedMessage));
        const timer = timer_1.Timer.getInstance({
            timerType: config.timerType,
            duration: config.timerDuration,
            durationUnit: config.timerDurationUnit,
            isTimerProgressUpdateEnabled: config.isRunningTimerProgressVisible,
            timerMaxLoopIterations: config.timerMaxLoopIterations,
            timerLoopTimeout: config.timerLoopTimeout,
            timerLoopTimeoutUnit: config.timerLoopTimeoutUnit,
        });
        timer.on('state', ({ state, progress }) => {
            if (state === timer_1.STATE.IDLE) {
                node.status({ fill: 'grey', shape: 'ring', text: 'Idle' });
            }
            if (state === timer_1.STATE.RUNNING) {
                node.status({ fill: 'green', shape: 'dot', text: `Running${progress}` });
            }
            if (state === timer_1.STATE.STOPPED) {
                node.status({ fill: 'red', shape: 'dot', text: 'Stopped' });
            }
            if (state === timer_1.STATE.PAUSED) {
                node.status({ fill: 'yellow', shape: 'dot', text: `Paused${progress}` });
            }
        });
        timer.on(timer_1.STATE.STOPPED, () => node.send([null, getHaltedMessage()]));
        timer.on(timer_1.STATE.PAUSED, () => node.send([null, getHaltedMessage()]));
        timer.on('timer', () => node.send([getTriggerMessage(), null]));
        timer.on('loop-timeout', () => node.send([null, getMessage(config.loopTimeoutMessage)]));
        timer.on('loop-max-iterations', () => node.send([null, getMessage(config.loopMaxIterationsMessage)]));
        node.on('input', (message, send, done) => {
            lastMessage = message;
            const isStartActionMessage = message[config.actionPropertyName] === config.startActionName && config.isStartActionEnabled;
            const isResetActionMessage = message[config.actionPropertyName] === config.resetActionName && config.isResetActionEnabled;
            const isPauseActionMessage = message[config.actionPropertyName] === config.pauseActionName && config.isPauseActionEnabled;
            const isContinueActionMessage = message[config.actionPropertyName] === config.continueActionName && config.isContinueActionEnabled;
            const isStopActionMessage = message[config.actionPropertyName] === config.stopActionName && config.isStopActionEnabled;
            const isUnknownMessage = !(isStartActionMessage || isResetActionMessage || isPauseActionMessage || isContinueActionMessage || isStopActionMessage);
            const timerTypeOverride = message[node_config_1.constants.timerTypeOverridePropertyName] ?? null;
            const timerDurationOverride = message[node_config_1.constants.timerDurationOverridePropertyName] ?? null;
            const timerDurationUnitOverride = message[node_config_1.constants.timerDurationUnitOverridePropertyName] ?? null;
            const isOverrideMessage = timerTypeOverride !== null && timerDurationOverride !== null && timerDurationUnitOverride !== null;
            if (isStartActionMessage && isOverrideMessage) {
                timer.setConfigOverride({
                    timerType: timerTypeOverride,
                    duration: timerDurationOverride,
                    durationUnit: timerDurationUnitOverride,
                });
            }
            if (timer.getState() === timer_1.STATE.PAUSED) {
                if (isStartActionMessage && config.continueTimerOnReceivalOfStartAction) {
                    timer.continue();
                    done();
                    return;
                }
            }
            if (timer.getState() !== timer_1.STATE.RUNNING) {
                if (isStartActionMessage || (isUnknownMessage && config.startTimerOnReceivalOfUnknownMessage)) {
                    timer.start();
                    done();
                    return;
                }
            }
            if (isResetActionMessage ||
                (isUnknownMessage && config.resetTimerOnReceivalOfUnknownMessage) ||
                (isStartActionMessage && config.resetTimerOnReceivalOfStartAction) ||
                (isStartActionMessage && isOverrideMessage)) {
                timer.reset();
                done();
                return;
            }
            if (isStopActionMessage) {
                timer.stop();
                done();
                return;
            }
            if (isPauseActionMessage) {
                timer.pause();
                done();
                return;
            }
            if (isContinueActionMessage) {
                timer.continue();
                done();
                return;
            }
        });
        node.on('close', (done) => {
            timer.hardReset();
            done();
        });
    });
};
